lecture fichier -> t_point tabpoint[]

main
init
	mlx->image = new_image(mlx);
	m.cam.x = 0.5
	m.cam.y = 0.5
	m.cam.scale  = 32
	m.cam.offsetx  = win_width / 2
	m.cam.offsety  = win_height / 2
/init 
read file 
	get map(with , height) -> t_map ma*
		m.vect =aloou : 1vecteur par point 
		m.deph_min = 0 
		m.deph_max = 0
		m.whith/height = whith/height
	Populate_map
		pour tout y 
			pour tout x
				m.vector[y * m.with + x ] = (c,y,z)
		m.deph.min/max = zmin , zmax 
/read file 
render
	pout tout x
		pour tout y
	|			vect = project_vector(vect(x,y),mlx) 
	|			v.x -= (double)(mlx->map->width - 1) / 2.0f;
	|			v.y -= (double)(mlx->map->height - 1) / 2.0f;
	|			v.z -= (double)(mlx->map->depth_min + mlx->map->depth_max) / 2.0f;
	|			v = rotate(v, mlx->cam);
	|					t_vector	rotate(t_vector p, t_cam *r)
	|						{
	|							t_vector	v;
	|							double		x;
	|							double		y;
	|							double		z;
	|						
	|							x = p.x;
	|							z = p.z;
	|							v.x = cos(r->y) * x + sin(r->y) * z;
	|							v.z = -sin(r->y) * x + cos(r->y) * z;
	|							y = p.y;
	|							z = v.z;
	|							v.y = cos(r->x) * y - sin(r->x) * z;
	|							v.z = sin(r->x) * y + cos(r->x) * z;
	|							v.color = p.color;
	|							return (v);
	|						}
	|				v.x *= mlx->cam->scale;
	|				v.y *= mlx->cam->scale;
	|				v.x += mlx->cam->offsetx;
	|				v.y += mlx->cam->offsety;
	|				return (v);
	|			si (x + 1 < xmax)
	|				line(mlx, vect, project_vector(vect (x + 1,y), mlx);
	|									void		line(t_mlx *mlx, t_vector p1, t_vector p2)
	|									{
	|										t_line	line;
	|									
	|										p1.x = (int)p1.x;
	|										p2.x = (int)p2.x;
	|										p1.y = (int)p1.y;
	|										p2.y = (int)p2.y;
	|										line.start = p1;
	|										line.stop = p2;
	|										if (!lineclip(&p1, &p2))
	|											return ;
	|										line.dx = (int)ft_abs((int)p2.x - (int)p1.x);
	|										line.sx = (int)p1.x < (int)p2.x ? 1 : -1;
	|										line.dy = (int)ft_abs((int)p2.y - (int)p1.y);
	|										line.sy = (int)p1.y < (int)p2.y ? 1 : -1;
	|										line.err = (line.dx > line.dy ? line.dx : -line.dy) / 2;
	|										while (((int)p1.x != (int)p2.x || (int)p1.y != (int)p2.y))
	|											if (line_process_point(mlx, &line, &p1, &p2))
	|												break ;
	|									}
	|			si (x + 1 < ymax)
	|				line(mlx, vect, project_vector(vect (x + 1,y +1), mlx);
	|			
	mlx_put_image_to_window(mlx->mlx, mlx->window, mlx->image->image, 0, 0);
/render
t_vector **vector 
